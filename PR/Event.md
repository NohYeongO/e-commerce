# **주문 처리 시스템의 개선된 이벤트 기반 설계**

---

## **1. 기존 방식의 문제점**
기존의 주문 처리 방식은 다음과 같은 한계가 있었습니다:

1. **로직 간 결합도가 높음**
    - 주문 처리, 잔고 차감, 데이터 전송, 재고 복구 로직이 한 메서드 또는 클래스에 집중되어 있었습니다.
    - 코드의 유지보수성과 가독성이 저하되었습니다.

2. **트랜잭션 관리의 불명확성**
    - 성공 또는 실패 시 후속 작업(예: 데이터 전송, 보상 트랜잭션)의 실행 시점이 명확하지 않았습니다.
    - 롤백 상황에서도 일부 작업이 실행되어 데이터 일관성이 깨질 가능성이 있었습니다.

3. **비동기 처리 부족**
    - 주문 데이터 플랫폼 전송과 같은 작업이 비동기로 처리되지 않아 메인 프로세스의 응답 시간이 길어졌습니다.

4. **보상 트랜잭션의 신뢰성 부족**
    - 보상 트랜잭션이 명확한 트랜잭션 경계 없이 실행되며, 실패 시 별도의 처리가 없었습니다.

---

## **2. 개선 방법**
기존의 문제를 해결하기 위해 다음과 같은 개선을 도입했습니다:

1. **이벤트 기반 설계 도입**
    - `ApplicationEventPublisher`와 `@TransactionalEventListener`를 사용해 주문 성공/실패 시점에 따라 후속 작업을 실행하도록 변경했습니다.
    - 성공/실패 이벤트(`OrderSuccessEvent`, `OrderFailedEvent`)를 정의하여 로직을 분리했습니다.

2. **트랜잭션 상태에 따른 이벤트 처리**
    - 성공 시: `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)`를 사용해 트랜잭션이 커밋된 후 이벤트를 실행.
    - 실패 시: `@TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)`를 사용해 트랜잭션 종료 후 재고 복구 작업(보상 트랜잭션)을 처리.

3. **비동기 처리 도입**
    - 성공 이벤트 리스너에 `@Async`를 적용해 데이터 플랫폼 전송과 같은 작업을 비동기로 처리.

4. **보상 트랜잭션의 신뢰성 강화**
    - 보상 트랜잭션에서 `Propagation.REQUIRES_NEW`를 사용해 기존 트랜잭션과 독립적인 트랜잭션 경계를 보장.
    - 실패 로그를 추가해 보상 트랜잭션 실패 시 문제를 추적할 수 있도록 개선.

---

## **3. 개선 후 좋아진 점**

1. **코드 모듈화 및 응집도 향상**
    - 주요 비즈니스 로직(주문 생성, 보상 트랜잭션, 데이터 전송)이 이벤트 리스너로 분리되어 각 기능이 독립적으로 관리 가능.

2. **트랜잭션 안정성 보장**
    - 트랜잭션 상태에 따라 정확히 작업을 분리(`AFTER_COMMIT`, `AFTER_COMPLETION`).
    - 보상 트랜잭션이 실패하더라도 원 트랜잭션에 영향을 주지 않도록 설계.

3. **비동기 처리로 성능 개선**
    - 데이터 플랫폼 전송 작업이 메인 프로세스와 분리되어 실행됨으로써, 메인 프로세스가 즉시 응답할 수 있게 됨

4. **유지보수성 강화**
    - 이벤트 기반 설계를 통해 각 로직 간 결합도가 낮아졌으며, 후속 작업 추가/변경이 쉬워짐.

5. **실패 시 복구 신뢰성 강화**
    - 보상 트랜잭션의 독립성(`Propagation.REQUIRES_NEW`)이 보장되며, 실패 로그 기록으로 디버깅 가능.

---

## **4. 결론**
이번 개선을 통해 기존 방식의 문제였던 결합도, 트랜잭션 관리 문제, 비동기 처리 부족을 해결했습니다.
특히 트랜잭션 분리를 통해 주문 기능의 안정성을 강화했던 기존 로직에서, 이를 이벤트 기반 처리와 결합함으로써 각 작업 간의 책임을 명확히 하고, 새로운 요구사항 추가에도 유연하게 대응할 수 있는 구조를 갖추게 되었습니다.
이 설계는 시스템의 유연성, 확장성, 안정성을 크게 향상시키며, 향후 변화하는 비즈니스 요구에도 빠르게 적응할 수 있는 기반을 제공합니다.
---